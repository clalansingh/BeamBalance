<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Beam Balance v0.1.7</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@400;700&display=swap');

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0; padding: 0; overflow: hidden;
            background-color: #0F172A;
            touch-action: none;
            font-family: 'Roboto', sans-serif;
            user-select: none; -webkit-user-select: none;
        }

        canvas { display: block; position: absolute; top: 0; left: 0; }
        #gameCanvas { z-index: 1; }
        #uiCanvas { z-index: 2; pointer-events: none; }

        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        .menu-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 23, 42, 0.98);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; transition: opacity 0.2s;
            pointer-events: auto; touch-action: pan-y;
        }

        .menu-container {
            overflow-y: auto; max-height: 90vh; width: 100%;
            display: flex; flex-direction: column; align-items: center;
            padding-bottom: 50px;
        }

        .neon-text { font-family: 'Orbitron', sans-serif; text-shadow: 0 0 15px rgba(239, 68, 68, 0.6); }
        .gold-text { font-family: 'Orbitron', sans-serif; color: #FBBF24; text-shadow: 0 0 15px rgba(251, 191, 36, 0.6); }

        .zone-hint {
            position: absolute; top: 50%; width: 120px; height: 120px;
            border: 2px dashed rgba(255,255,255,0.1); border-radius: 50%;
            transform: translate(-50%, -50%); display: flex; align-items: center;
            justify-content: center; color: rgba(255,255,255,0.2);
            font-size: 12px; text-align: center; pointer-events: none;
        }

        @keyframes pulse-gold {
            0%, 100% { transform: scale(1); text-shadow: 0 0 20px rgba(251, 191, 36, 0.6); }
            50% { transform: scale(1.1); text-shadow: 0 0 40px rgba(251, 191, 36, 1); }
        }
        .high-score-anim { animation: pulse-gold 1.5s infinite; }
        
        /* BUTTON STYLES */
        .game-btn {
            width: 100%; max-width: 300px; margin-bottom: 15px; padding: 15px;
            border-radius: 10px; border: 1px solid; cursor: pointer;
            display: flex; flex-direction: column; align-items: center;
            transition: transform 0.1s; position: relative; z-index: 101;
            touch-action: manipulation; background-color: #333; color: white;
        }
        .game-btn:active { transform: scale(0.96); }

        #systemLog {
            position: absolute; top: 0; left: 0; padding: 5px;
            color: #FFFF00; font-family: monospace; font-size: 10px;
            z-index: 9999; pointer-events: none; opacity: 0.8;
            background: rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>

    <!-- SCRIPT 1: ERROR LOGGER (Runs Instantly) -->
    <script>
        window.logQueue = [];
        function sysLog(msg) {
            window.logQueue.push(msg);
            const el = document.getElementById('systemLog');
            if(el) el.innerText = "SYS: " + msg;
            console.log(msg);
        }
        window.onerror = function(msg, source, lineno) {
            const err = `ERR: ${msg} (${lineno})`;
            const el = document.getElementById('systemLog');
            if(el) {
                el.innerText = err;
                el.style.color = "red";
                el.style.backgroundColor = "rgba(0,0,0,0.9)";
            }
        };
        sysLog("Boot Sequence Started...");
    </script>

    <div id="systemLog">Booting...</div>

    <canvas id="gameCanvas"></canvas>
    <canvas id="uiCanvas"></canvas>

    <div id="touchLayer" style="position:absolute; top:0; left:0; width:100%; height:100%; z-index: 5;"></div>

    <div class="ui-layer">
        <div class="flex justify-between p-6">
            <div class="text-white text-2xl font-bold neon-text"><span class="text-red-500">DANGER</span> ZONE</div>
            <div class="flex flex-col items-end">
                <div class="text-blue-400 text-3xl font-mono font-bold" id="scoreDisplay">0m</div>
                <div class="text-gray-500 text-sm font-mono"><span id="difficultyLabel">NORMAL</span> | BEST: <span id="hudBestScore">0</span>m</div>
            </div>
        </div>
        <div id="leftHint" class="zone-hint" style="left: 15%">LEFT THUMB</div>
        <div id="rightHint" class="zone-hint" style="left: 85%">RIGHT THUMB</div>
    </div>

    <!-- MENU SCREEN -->
    <div id="menuScreen" class="menu-screen">
        <div class="menu-container">
            <h1 class="text-5xl md:text-7xl text-white font-bold mb-2 neon-text tracking-widest text-center mt-10">BEAM<br><span class="text-blue-500">BALANCE</span></h1>
            <p class="text-gray-400 mb-6 text-center max-w-md px-6 text-lg leading-relaxed">
                Magnetic Rail System Active<br>
                <span class="text-blue-400 text-sm">(Physics: Snappy | Density: High)</span>
            </p>
            
            <div class="flex flex-col gap-3 w-full max-w-xs px-4 mb-10">
                <!-- Normal -->
                <div id="btnNormal" class="game-btn" style="background-color: #2563EB; border-color: #60A5FA;">
                    <span class="text-lg font-bold tracking-wider">NORMAL</span>
                    <span class="text-xs text-blue-200 opacity-80">BEST: <span id="menuNormalBest">0</span>m</span>
                </div>

                <!-- Hard -->
                <div id="btnHard" class="game-btn" style="background-color: #581C87; border-color: #A855F7;">
                    <span class="text-lg font-bold tracking-wider text-purple-100">HARD</span>
                    <span class="text-xs text-purple-300 opacity-80">BEST: <span id="menuHardBest">0</span>m</span>
                </div>

                <!-- Very Hard -->
                <div id="btnVeryHard" class="game-btn" style="background-color: #7F1D1D; border-color: #EF4444;">
                    <span class="text-lg font-bold tracking-wider text-red-100">VERY HARD</span>
                    <span class="text-xs text-red-300 opacity-80">BEST: <span id="menuVeryHardBest">0</span>m</span>
                </div>
            </div>
        </div>
        <div class="absolute bottom-4 right-4 text-gray-600 text-xs font-mono select-none opacity-50">v0.1.7</div>
    </div>

    <!-- GAME OVER SCREEN -->
    <div id="gameOverScreen" class="menu-screen" style="display: none;">
        <div id="newRecordMessage" class="hidden mb-6 flex flex-col items-center">
            <div class="text-6xl mb-2">üèÜ</div>
            <h2 class="text-4xl font-bold gold-text high-score-anim text-center">NEW HIGH SCORE!</h2>
            <div class="text-yellow-500 font-mono mt-2" id="recordModeLabel">NORMAL MODE</div>
        </div>

        <h2 id="normalDeathTitle" class="text-6xl text-red-500 font-bold mb-2 neon-text">VOIDED</h2>
        <p id="deathReason" class="text-gray-400 mb-6">Fell into a hole</p>
        
        <div class="text-5xl text-white mb-2 font-mono font-bold"><span id="finalScore">0</span>m</div>
        <div class="text-xl text-gray-500 mb-8 font-mono">Mode Best: <span id="endBestScore">0</span>m</div>
        
        <div id="btnRetry" class="game-btn" style="background-color: #16A34A; border-color: #4ADE80;">RETRY</div>
        <div id="btnMenu" class="game-btn" style="background-color: transparent; border-color: #4B5563; color: #9CA3AF;">CHANGE DIFFICULTY</div>
    </div>

    <!-- SCRIPT 2: GAME ENGINE -->
    <script>
        // --- GLOBAL VARIABLES (Declarations) ---
        let canvas, ctx, uiCanvas, uiCtx, touchLayer;
        let menuScreen, gameOverScreen, leftHint, rightHint;
        let animationFrameId;

        const GRAVITY = 1000;
        const SCROLL_SPEED_BASE = 130;
        const BALL_RADIUS = 12;
        const BEAM_THICKNESS = 8;
        const MIN_GAP = 24 * 2.5;
        const SNAP_DISTANCE = 25;
        const ROLL_BOOST = 1.8;
        const RAIL_FRICTION = 0.98;
        const VOID_SPEED = 40;
        const CURRENT_ZONE_HEIGHT = 500;

        let isPlaying = false, lastTime = 0, score = 0, scrollSpeed = 0, cameraY = 0;
        let currentDifficulty = 'NORMAL';
        let bgColor = { r: 15, g: 23, b: 42 };
        let bestNormal = 0, bestHard = 0, bestVeryHard = 0;

        let ball = { x: 0, y: 0, vx: 0, vy: 0, magnetized: false };
        let holes = [], particles = [], bgStars = [];
        let leftThumb = null, rightThumb = null, beam = null, rawBeam = null;

        // --- CORE FUNCTIONS ---

        function loadScores() {
            try {
                const n = localStorage.getItem('beam_balance_normal_best');
                const h = localStorage.getItem('beam_balance_hard_best');
                const v = localStorage.getItem('beam_balance_veryhard_best');
                bestNormal = n ? parseInt(n) : 0;
                bestHard = h ? parseInt(h) : 0;
                bestVeryHard = v ? parseInt(v) : 0;
            } catch(e) { sysLog("Storage Skipped"); }
            updateMenuUI();
        }

        function saveScore(newScore) {
            try {
                let isBest = false;
                if (currentDifficulty === 'NORMAL' && newScore > bestNormal) {
                    bestNormal = newScore; localStorage.setItem('beam_balance_normal_best', bestNormal); isBest = true;
                } else if (currentDifficulty === 'HARD' && newScore > bestHard) {
                    bestHard = newScore; localStorage.setItem('beam_balance_hard_best', bestHard); isBest = true;
                } else if (currentDifficulty === 'VERY_HARD' && newScore > bestVeryHard) {
                    bestVeryHard = newScore; localStorage.setItem('beam_balance_veryhard_best', bestVeryHard); isBest = true;
                }
                return isBest;
            } catch(e) { return false; }
        }

        function updateMenuUI() {
            const b1 = document.getElementById('menuNormalBest');
            const b2 = document.getElementById('menuHardBest');
            const b3 = document.getElementById('menuVeryHardBest');
            if(b1) b1.innerText = bestNormal;
            if(b2) b2.innerText = bestHard;
            if(b3) b3.innerText = bestVeryHard;
        }

        function resize() {
            if(!canvas) return;
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            uiCanvas.width = window.innerWidth; uiCanvas.height = window.innerHeight;
            bgStars = [];
            for(let i=0; i<60; i++) bgStars.push({x:Math.random()*canvas.width, y:Math.random()*canvas.height, size:Math.random()*2.5, speed:0.2+Math.random()*0.5});
        }

        function initGame(difficulty) {
            sysLog("Game Start: " + difficulty);
            if(isPlaying) return;

            currentDifficulty = difficulty;
            const dl = document.getElementById('difficultyLabel');
            const hb = document.getElementById('hudBestScore');
            
            dl.innerText = difficulty;
            if(difficulty === 'NORMAL') { dl.className='text-blue-300'; hb.innerText=bestNormal; }
            else if(difficulty === 'HARD') { dl.className='text-purple-400 font-bold'; hb.innerText=bestHard; }
            else { dl.className='text-red-400 font-bold'; hb.innerText=bestVeryHard; }

            resetGameLogic();
            
            menuScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            leftHint.style.opacity = 0; rightHint.style.opacity = 0;

            isPlaying = true;
            lastTime = performance.now();
            cancelAnimationFrame(animationFrameId);
            requestAnimationFrame(loop);
        }

        function resetGameLogic() {
            resize();
            score = 0; cameraY = 0; scrollSpeed = SCROLL_SPEED_BASE;
            bgColor = { r: 15, g: 23, b: 42 };
            ball = { x: window.innerWidth/2, y: 100, vx: 0, vy: 0, magnetized: false };
            holes = []; generateHoles(window.innerHeight * 0.75, window.innerHeight * 2.5);
            particles = []; leftThumb = null; rightThumb = null; beam = null; rawBeam = null;
        }

        function generateHoles(startY, endY) {
            const stepY = 50; let currentY = startY;
            while (currentY < endY) {
                const attempts = 20; 
                for (let i = 0; i < attempts; i++) {
                    const r = 25 + Math.random() * 30; 
                    const margin = r + 10;
                    const candidateX = margin + Math.random() * (window.innerWidth - margin * 2);
                    const candidateY = currentY + (Math.random() * 60 - 30); 
                    const newHole = { x: candidateX, y: candidateY, r: r, id: Math.random() };
                    let valid = true;
                    for (let h of holes) {
                        if (Math.abs(h.y - newHole.y) > 200) continue;
                        const dx = h.x - newHole.x; const dy = h.y - newHole.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < h.r + newHole.r + MIN_GAP) { valid = false; break; }
                    }
                    if (valid) holes.push(newHole);
                }
                currentY += stepY;
            }
            holes.sort((a,b) => a.y - b.y);
        }

        function update(dt) {
            if (currentDifficulty === 'NORMAL') scrollSpeed = SCROLL_SPEED_BASE + (score / 4);
            else {
                scrollSpeed = SCROLL_SPEED_BASE + (score / 1.5); 
                const p = Math.min(score / 500, 1); 
                bgColor.r = 15 * (1 - p); bgColor.g = 23 * (1 - p); bgColor.b = 42 * (1 - p);
            }
            
            cameraY += scrollSpeed * dt;
            score = Math.floor(cameraY / 10);
            document.getElementById('scoreDisplay').innerText = score + "m";

            holes = holes.filter(h => h.y > cameraY - 300);
            if (holes.length > 0 && holes[holes.length-1].y < cameraY + window.innerHeight + 800) {
                generateHoles(holes[holes.length-1].y, cameraY + window.innerHeight + 1600);
            }

            if (currentDifficulty === 'VERY_HARD') {
                for (let h of holes) {
                    const z = Math.floor(h.y / CURRENT_ZONE_HEIGHT);
                    const d = (z % 2 === 0) ? -1 : 1;
                    h.x += d * VOID_SPEED * dt;
                    if (d === -1 && h.x < -h.r) h.x = window.innerWidth + h.r; 
                    else if (d === 1 && h.x > window.innerWidth + h.r) h.x = -h.r;
                }
            }

            if (leftThumb && rightThumb) {
                rawBeam = { x1: leftThumb.x, y1: leftThumb.y, x2: rightThumb.x, y2: rightThumb.y };
                const rawX1 = leftThumb.x; const rawY1 = leftThumb.y + cameraY;
                const rawX2 = rightThumb.x; const rawY2 = rightThumb.y + cameraY;
                const dx = rawX2 - rawX1; const dy = rawY2 - rawY1;
                const len = Math.sqrt(dx*dx + dy*dy);
                const unitX = dx / len; const unitY = dy / len;
                const EXTENSION = 3000;
                beam = {
                    x1: rawX1 - unitX * EXTENSION, y1: rawY1 - unitY * EXTENSION,
                    x2: rawX2 + unitX * EXTENSION, y2: rawY2 + unitY * EXTENSION,
                    nx: -unitY, ny: unitX, len: len + (EXTENSION * 2),
                };
                if (beam.ny > 0) { beam.nx = -beam.nx; beam.ny = -beam.ny; }
            } else {
                beam = null; rawBeam = null; ball.magnetized = false; 
            }

            if (ball.magnetized && beam) {
                const m = (beam.y2 - beam.y1) / (beam.x2 - beam.x1);
                const targetY = m * (ball.x - beam.x1) + beam.y1;
                ball.y = targetY - (BALL_RADIUS + BEAM_THICKNESS/2);
                ball.vy = 0; 
                const angle = Math.atan2(beam.y2 - beam.y1, beam.x2 - beam.x1);
                const gForce = GRAVITY * Math.sin(angle) * ROLL_BOOST; 
                ball.vx += gForce * dt;
                ball.vx *= RAIL_FRICTION; 
            } else {
                ball.vy += GRAVITY * dt; ball.vx *= 0.99; ball.y += ball.vy * dt;
                if (beam) {
                    const dx = beam.x2 - beam.x1; const dy = beam.y2 - beam.y1;
                    const t = ((ball.x - beam.x1) * dx + (ball.y - beam.y1) * dy) / (beam.len * beam.len);
                    const closeX = beam.x1 + t * dx; const closeY = beam.y1 + t * dy;
                    const dist = Math.sqrt((ball.x - closeX)**2 + (ball.y - closeY)**2);
                    if (dist < BALL_RADIUS + SNAP_DISTANCE) {
                        const relX = ball.x - beam.x1; const relY = ball.y - beam.y1;
                        const dotNormal = relX * beam.nx + relY * beam.ny;
                        if (dotNormal > -BALL_RADIUS) {
                            ball.magnetized = true; spawnSparks(ball.x, ball.y, 3); 
                        }
                    }
                }
            }
            ball.x += ball.vx * dt;

            for (let h of holes) {
                const dx = ball.x - h.x; const dy = ball.y - h.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < h.r + 50) {
                    const pull = 1 - (dist / (h.r+50));
                    let f = 700 * pull * dt;
                    if(ball.magnetized) f *= 0.3;
                    else { ball.vx += (h.x - ball.x)/dist * f; ball.vy += (h.y - ball.y)/dist * f; }
                }
                if (dist < h.r - (BALL_RADIUS * 0.4)) { lose("Consumed by Void"); return; }
            }

            const screenY = ball.y - cameraY;
            if (screenY < -200) lose("Lost in Space"); 
            if (screenY > window.innerHeight + 100) lose("Fell Behind"); 
            if (ball.x < 0 || ball.x > window.innerWidth) lose("Off Screen"); 

            updateParticles(dt);
        }

        function lose(reason) {
            isPlaying = false;
            document.getElementById('deathReason').innerText = reason;
            document.getElementById('finalScore').innerText = score;
            
            const isNewRecord = saveScore(score);
            const newRecMsg = document.getElementById('newRecordMessage');
            const normTitle = document.getElementById('normalDeathTitle');
            const bestLabel = document.getElementById('endBestScore');
            
            if (isNewRecord) {
                newRecMsg.classList.remove('hidden');
                normTitle.classList.add('hidden');
                document.getElementById('recordModeLabel').innerText = currentDifficulty + " MODE";
                bestLabel.innerText = score;
            } else {
                newRecMsg.classList.add('hidden');
                normTitle.classList.remove('hidden');
                bestLabel.innerText = (currentDifficulty==='NORMAL'?bestNormal:(currentDifficulty==='HARD'?bestHard:bestVeryHard));
            }
            
            gameOverScreen.style.display = 'flex';
            leftHint.style.opacity = 1; rightHint.style.opacity = 1;
        }

        function spawnSparks(x, y, count) {
            for(let i=0; i<count; i++) particles.push({ x:x, y:y, vx:(Math.random()-0.5)*200, vy:(Math.random()-0.5)*200, life:0.3+Math.random()*0.2, 
