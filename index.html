<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Beam Balance</title>
    <style>
        /* Fallback font system */
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@400;700&display=swap');

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0; padding: 0;
            width: 100vw; 
            height: 100vh;
            overflow: hidden;
            background-color: #0F172A;
            touch-action: none; 
            font-family: 'Roboto', sans-serif;
            user-select: none; -webkit-user-select: none;
            color: white;
        }

        canvas { display: block; position: absolute; top: 0; left: 0; }
        #gameCanvas { z-index: 1; }
        #uiCanvas { z-index: 2; pointer-events: none; }

        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        .top-bar { padding: 20px; display: flex; justify-content: space-between; align-items: flex-start; }
        .score-box { text-align: right; pointer-events: none; }

        /* Inventory UI */
        .inventory-box {
            width: 60px; height: 60px;
            border: 2px solid #475569;
            background: rgba(15, 23, 42, 0.8);
            border-radius: 12px;
            display: flex; align-items: center; justify-content: center;
            pointer-events: none; /* No longer clickable, passive display */
            transition: transform 0.1s;
        }
        .inv-icon { font-family: 'Orbitron', sans-serif; font-weight: bold; font-size: 24px; }
        .inv-hint { font-size: 10px; color: #94A3B8; text-align: center; margin-top: 4px; font-family: monospace;}

        .neon-danger { font-family: 'Orbitron', sans-serif; text-shadow: 0 0 15px rgba(239, 68, 68, 0.8); font-size: 1.5rem; font-weight: bold; }
        .score-main { font-family: monospace; font-size: 2rem; color: #60A5FA; font-weight: bold; }
        .score-sub { font-family: monospace; font-size: 0.8rem; color: #6B7280; }

        .zone-hint {
            position: absolute; top: 50%; width: 100px; height: 100px;
            border: 2px dashed rgba(255,255,255,0.15); border-radius: 50%;
            transform: translate(-50%, -50%); display: flex; align-items: center;
            justify-content: center; color: rgba(255,255,255,0.3);
            font-size: 10px; text-align: center; pointer-events: none;
        }

        /* SCREENS */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #0F172A; 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; 
            pointer-events: auto; 
            touch-action: pan-y;
        }

        .menu-container {
            width: 100%; max-width: 320px; padding: 0 20px;
            margin: 0 auto;
            display: flex; flex-direction: column; align-items: center;
            max-height: 90vh; overflow-y: auto;
        }

        .title { font-family: 'Orbitron', sans-serif; font-size: 3rem; font-weight: bold; text-align: center; margin-bottom: 10px; letter-spacing: 0.1em; text-shadow: 0 0 15px rgba(59, 130, 246, 0.5); }
        .subtitle { color: #9CA3AF; text-align: center; margin-bottom: 30px; font-size: 0.9rem; line-height: 1.5; }
        .highlight-blue { color: #60A5FA; }

        /* BUTTONS */
        .btn-container { width: 100%; display: flex; flex-direction: column; gap: 15px; margin-bottom: 20px; }

        .game-btn {
            width: 100%; padding: 15px;
            border-radius: 12px; border: 2px solid;
            cursor: pointer; text-align: center;
            transition: transform 0.1s, opacity 0.1s;
            position: relative; overflow: hidden;
            background: #1E293B; color: white;
            touch-action: manipulation;
        }
        .game-btn:active { transform: scale(0.96); opacity: 0.9; }

        .btn-normal { border-color: #3B82F6; background: linear-gradient(45deg, #1E3A8A, #1D4ED8); box-shadow: 0 0 15px rgba(37, 99, 235, 0.3); }
        .btn-hard { border-color: #A855F7; background: linear-gradient(45deg, #581C87, #7E22CE); box-shadow: 0 0 15px rgba(126, 34, 206, 0.3); }
        .btn-veryhard { border-color: #EF4444; background: linear-gradient(45deg, #7F1D1D, #B91C1C); box-shadow: 0 0 15px rgba(185, 28, 28, 0.3); }
        .btn-retry { border-color: #22C55E; background: linear-gradient(45deg, #14532D, #15803D); }
        .btn-menu { background: transparent; border-color: #6B7280; color: #9CA3AF; }

        .btn-label { display: block; font-size: 1.2rem; font-weight: bold; font-family: 'Orbitron', sans-serif; letter-spacing: 0.05em; margin-bottom: 4px; }
        .btn-score { display: block; font-size: 0.75rem; opacity: 0.8; font-family: monospace; }

        #systemLog {
            position: absolute; top: 0; left: 0; padding: 4px;
            color: yellow; background: rgba(0,0,0,0.5);
            font-family: monospace; font-size: 10px; z-index: 9999;
            pointer-events: none; display: none;
        }
    </style>
</head>
<body>

    <div id="systemLog"></div>

    <canvas id="gameCanvas"></canvas>
    <canvas id="uiCanvas"></canvas>

    <div id="touchLayer" style="position:absolute; top:0; left:0; width:100%; height:100%; z-index: 5;"></div>

    <!-- HUD -->
    <div id="hudLayer" class="ui-layer" style="display:none;">
        <div class="top-bar">
            <!-- INVENTORY SLOT -->
            <div id="inventorySlot" class="inventory-box">
                <!-- Content injected by JS -->
            </div>

            <div class="score-box">
                <div id="scoreDisplay" class="score-main">0m</div>
                <div class="score-sub"><span id="difficultyLabel">NORMAL</span> | BEST: <span id="hudBestScore">0</span>m</div>
            </div>
        </div>
        <div id="leftHint" class="zone-hint" style="left: 15%">LEFT THUMB</div>
        <div id="rightHint" class="zone-hint" style="left: 85%">RIGHT THUMB</div>
        
        <!-- Visual Alert for Slow/Shield/Teleport -->
        <div id="activeEffectLabel" style="position: absolute; top: 80px; left: 20px; font-family: 'Orbitron'; font-size: 14px; color: #FBBF24; display: none; text-shadow: 0 0 5px rgba(0,0,0,0.8);">
            <!-- Injected by JS -->
        </div>
    </div>

    <!-- MENU SCREEN -->
    <div id="menuScreen" class="screen">
        <div class="menu-container">
            <div class="title">BEAM<br><span class="highlight-blue">BALANCE</span></div>
            <div class="subtitle">Magnetic Rail System<br><span id="versionDisplay"></span></div> 
            
            <div class="btn-container">
                <div id="btnNormal" class="game-btn btn-normal">
                    <span class="btn-label">NORMAL</span>
                    <span class="btn-score">BEST: <span id="menuNormalBest">0</span>m</span>
                </div>
                <div id="btnHard" class="game-btn btn-hard">
                    <span class="btn-label" style="color:#E9D5FF">HARD</span>
                    <span class="btn-score" style="color:#E9D5FF">BEST: <span id="menuHardBest">0</span>m</span>
                </div>
                <div id="btnVeryHard" class="game-btn btn-veryhard">
                    <span class="btn-label" style="color:#FECACA">VERY HARD</span>
                    <span class="btn-score" style="color:#FECACA">BEST: <span id="menuVeryHardBest">0</span>m</span>
                </div>
            </div>
        </div>
    </div>

    <!-- GAME OVER SCREEN -->
    <div id="gameOverScreen" class="screen" style="display: none;">
        <div class="menu-container">
            <div id="newRecordMessage" style="display: none; margin-bottom: 20px; text-align: center;">
                <div style="font-size: 3rem;">üèÜ</div>
                <div style="font-family: 'Orbitron'; color: #FBBF24; font-size: 1.5rem; font-weight: bold;">NEW RECORD!</div>
                <div style="color: #F59E0B; font-family: monospace;" id="recordModeLabel">NORMAL MODE</div>
            </div>

            <div id="normalDeathTitle" class="title" style="color: #EF4444; font-size: 2.5rem;">VOIDED</div>
            <div class="subtitle" id="deathReason">Fell into the void</div>
            <div class="score-main" style="font-size: 3rem; margin-bottom: 10px;"><span id="finalScore">0</span>m</div>
            <div class="subtitle">MODE BEST: <span id="endBestScore">0</span>m</div>
            
            <div class="btn-container">
                <div id="btnRetry" class="game-btn btn-retry">
                    <span class="btn-label">RETRY</span>
                </div>
                <div id="btnMenu" class="game-btn btn-menu">
                    <span class="btn-label" style="font-size: 0.9rem">CHANGE DIFFICULTY</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // =================================================================
        // --- UTILITIES & SYSTEM LOGGING ---
        // =================================================================

        const sysLog = document.getElementById('systemLog');
        function log(msg) {
            console.log(msg);
            if(sysLog) {
                sysLog.style.display = 'block';
                sysLog.innerText = "LOG: " + msg;
            }
        }
        window.onerror = function(msg) { log(msg); };

        function resize() {
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            uiCanvas.width = window.innerWidth; uiCanvas.height = window.innerHeight;
            bgStars = [];
            for(let i=0; i<60; i++) bgStars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 2.5,
                speed: 0.2 + Math.random() * 0.5 
            });
        }
        
        // =================================================================
        // --- PHYSICS CONSTANTS ---
        // =================================================================

        const GRAVITY = 1000;          
        const SCROLL_SPEED_BASE = 130; 
        const BALL_RADIUS = 12;        
        const BEAM_THICKNESS = 8;      
        const MIN_GAP = 60;            
        const SNAP_DISTANCE = 25;      
        const ROLL_BOOST = 1.8;        
        const RAIL_FRICTION = 0.98;    
        const VOID_SPEED = 40;         
        const CURRENT_ZONE_HEIGHT = 500; 
        
        const VERSION = "v0.2.12"; // Bumped version

        // Power-Up Constants
        const POWERUP_FREQ_PIXELS = 100 * 10; // 100m (1m = 10px) = 1000px
        const POWERUP_TYPES = [
            // prob is cumulative threshold
            { type: 'SHIELD', color: '#3B82F6', label: 'S', prob: 0.50 }, // Blue
            { type: 'TELEPORT', color: '#06B6D4', label: 'T', prob: 0.75 }, 
            { type: 'SLOW', color: '#EAB308', label: 'Z', prob: 1.00 }      
        ];

        // =================================================================
        // --- GLOBAL GAME STATE ---
        // =================================================================
        
        let canvas, ctx, uiCanvas, uiCtx, touchLayer;
        let menuScreen, gameOverScreen, leftHint, rightHint, hudLayer;
        let invSlot, activeEffectLabel, slowTimerDisplay;
        
        let animationFrameId;
        let isBooted = false;
        let isPlaying = false; 
        let lastTime = 0; 
        
        let score = 0; 
        let scrollSpeed = 0; 
        let cameraY = 0; 
        let currentDifficulty = 'NORMAL';
        let bgColor = { r: 15, g: 23, b: 42 }; 

        let bestNormal = 0, bestHard = 0, bestVeryHard = 0;

        let ball = { x: 0, y: 0, vx: 0, vy: 0, magnetized: false };
        let holes = [];       
        let particles = [];   
        let powerUps = [];    // Array of power-up entities in world
        let bgStars = [];     

        let leftThumb = null;  
        let rightThumb = null; 
        let beam = null;       
        let rawBeam = null;    

        // Power-up State
        let inventory = null; // null, 'SHIELD', 'TELEPORT', 'SLOW'
        let shieldActive = false;
        let slowTimer = 0;
        let teleportMode = false; // New freeze state
        let teleportTimer = 0;    // Countdown for teleport
        
        let wasBeamActive = false; 
        let lastPowerUpY = 0; 

        // =================================================================
        // --- LIFECYCLE ---
        // =================================================================

        function boot() {
            if (isBooted) return;
            isBooted = true;

            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            uiCanvas = document.getElementById('uiCanvas');
            uiCtx = uiCanvas.getContext('2d');
            touchLayer = document.getElementById('touchLayer');
            
            menuScreen = document.getElementById('menuScreen');
            gameOverScreen = document.getElementById('gameOverScreen');
            hudLayer = document.getElementById('hudLayer');
            leftHint = document.getElementById('leftHint');
            rightHint = document.getElementById('rightHint');
            invSlot = document.getElementById('inventorySlot');
            activeEffectLabel = document.getElementById('activeEffectLabel');
            slowTimerDisplay = document.getElementById('slowTimerDisplay');

            resize();
            window.addEventListener('resize', resize);
            loadScores(); 
            
            document.title = `Beam Balance ${VERSION}`;
            document.getElementById('versionDisplay').innerText = VERSION;

            // Inputs
            touchLayer.ontouchstart = handleTouch;
            touchLayer.ontouchmove = handleTouch;
            touchLayer.ontouchend = handleTouch;
            touchLayer.ontouchcancel = handleTouch;
            touchLayer.onmousedown = handleMouse;
            touchLayer.onmousemove = handleMouse;
            touchLayer.onmouseup = () => { leftThumb = null; rightThumb = null; };

            // UI Bindings
            const bind = (id, fn) => {
                const el = document.getElementById(id);
                if(el) el.onclick = (e) => { e.stopPropagation(); fn(); };
            };
            bind('btnNormal', () => initGame('NORMAL'));
            bind('btnHard', () => initGame('HARD'));
            bind('btnVeryHard', () => initGame('VERY_HARD'));
            bind('btnRetry', () => initGame(currentDifficulty));
            bind('btnMenu', showMenu);
        }

        function showMenu() {
            gameOverScreen.style.display = 'none';
            hudLayer.style.display = 'none';
            menuScreen.style.display = 'flex';
            updateMenuUI();
        }

        function initGame(difficulty) {
            if(isPlaying) return;
            currentDifficulty = difficulty;
            
            const dl = document.getElementById('difficultyLabel');
            const hb = document.getElementById('hudBestScore');
            dl.innerText = difficulty;
            
            let best = 0;
            if(difficulty === 'NORMAL') { dl.style.color = '#60A5FA'; best = bestNormal; }
            else if(difficulty === 'HARD') { dl.style.color = '#C084FC'; best = bestHard; }
            else { dl.style.color = '#F87171'; best = bestVeryHard; }
            hb.innerText = best;

            resetGameLogic();
            
            menuScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            hudLayer.style.display = 'block';
            leftHint.style.opacity = 0; rightHint.style.opacity = 0;

            isPlaying = true;
            lastTime = performance.now();
            cancelAnimationFrame(animationFrameId);
            requestAnimationFrame(loop);
        }

        function resetGameLogic() {
            resize();
            score = 0; cameraY = 0; scrollSpeed = SCROLL_SPEED_BASE;
            bgColor = { r: 15, g: 23, b: 42 };
            ball = { x: window.innerWidth/2, y: 100, vx: 0, vy: 0, magnetized: false };
            holes = []; 
            powerUps = [];
            
            // Reset Powerups
            inventory = null;
            shieldActive = false;
            slowTimer = 0;
            wasBeamActive = false;
            teleportMode = false;
            teleportTimer = 0;
            lastPowerUpY = window.innerHeight; 

            updateInventoryUI();
            // Clear any stuck label
            activeEffectLabel.style.display = 'none';

            generateHoles(window.innerHeight * 0.75, window.innerHeight * 2.5); 
            particles = []; 
            leftThumb = null; rightThumb = null; beam = null; rawBeam = null;
        }

        function lose(reason) {
            isPlaying = false;
            document.getElementById('deathReason').innerText = reason;
            document.getElementById('finalScore').innerText = score;
            
            const isNewRecord = saveScore(score);
            const newRec = document.getElementById('newRecordMessage');
            const normTitle = document.getElementById('normalDeathTitle');
            const endBest = document.getElementById('endBestScore');
            
            if (isNewRecord) {
                newRec.style.display = 'block';
                normTitle.style.display = 'none';
                document.getElementById('recordModeLabel').innerText = currentDifficulty + " MODE";
                endBest.innerText = score;
            } else {
                newRec.style.display = 'none';
                normTitle.style.display = 'block';
                let best = 0;
                if(currentDifficulty === 'NORMAL') best = bestNormal;
                else if(currentDifficulty === 'HARD') best = bestHard;
                else best = bestVeryHard;
                endBest.innerText = best;
            }
            
            gameOverScreen.style.display = 'flex';
            hudLayer.style.display = 'none';
        }

        // =================================================================
        // --- LOGIC ---
        // =================================================================

        function generateHoles(startY, endY) {
            const stepY = 50; let currentY = startY;
            while (currentY < endY) {
                const attempts = 20; 
                for (let i = 0; i < attempts; i++) {
                    const r = 25 + Math.random() * 30; 
                    const margin = r + 10;
                    const candidateX = margin + Math.random() * (window.innerWidth - margin * 2);
                    const candidateY = currentY + (Math.random() * 60 - 30); 
                    const newHole = { x: candidateX, y: candidateY, r: r, id: Math.random() };
                    
                    let valid = true;
                    for (let h of holes) {
                        if (Math.abs(h.y - newHole.y) > 200) continue; 
                        const dx = h.x - newHole.x; const dy = h.y - newHole.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < h.r + newHole.r + MIN_GAP) { valid = false; break; }
                    }
                    if (valid) holes.push(newHole);
                }
                currentY += stepY;
            }
            holes.sort((a,b) => a.y - b.y);
        }

        function generatePowerUpsCheck(startY, endY) {
            if (lastPowerUpY < cameraY + window.innerHeight) {
                const spawnY = lastPowerUpY + POWERUP_FREQ_PIXELS + (Math.random() * 200);
                
                if (spawnY < endY) {
                    let placed = false;
                    for(let k=0; k<10; k++) {
                        const px = 40 + Math.random() * (window.innerWidth - 80);
                        const pr = 20; 
                        
                        let safe = true;
                        for (let h of holes) {
                            if (Math.abs(h.y - spawnY) > 200) continue;
                            const dx = h.x - px; const dy = h.y - spawnY;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist < h.r + pr + 20) { safe = false; break; }
                        }
                        
                        if (safe) {
                            const roll = Math.random();
                            let pType = POWERUP_TYPES[0].type;
                            for(let pt of POWERUP_TYPES) {
                                if(roll <= pt.prob) { pType = pt.type; break; }
                            }
                            
                            powerUps.push({ x: px, y: spawnY, r: pr, type: pType, collected: false });
                            placed = true;
                            break;
                        }
                    }
                    lastPowerUpY = spawnY;
                }
            }
        }

        function update(dt) {
            // --- TELEPORT MODE (Game Frozen) ---
            if (teleportMode) {
                teleportTimer -= dt;
                
                // Show countdown
                activeEffectLabel.style.display = 'block';
                activeEffectLabel.style.color = '#06B6D4';
                activeEffectLabel.innerHTML = `TAP TO TELEPORT! ${(teleportTimer).toFixed(1)}s`;

                if (teleportTimer <= 0) {
                    teleportMode = false; // Auto-resume
                    activeEffectLabel.style.display = 'none';
                }
                
                // Update particles only (for visual flare during freeze)
                updateParticles(dt);
                return; // SKIP PHYSICS & SCROLLING
            }

            // --- NORMAL UPDATE ---

            // 1. SLOWDOWN LOGIC
            let physicsDt = dt;
            if (slowTimer > 0) {
                slowTimer -= dt;
                physicsDt = dt * 0.5; // 50% speed
                activeEffectLabel.style.display = 'block';
                activeEffectLabel.style.color = '#FBBF24';
                activeEffectLabel.innerHTML = `SLOW MOTION ${(slowTimer).toFixed(1)}s`;
            } else {
                // Hide label only if not Teleporting
                if (!teleportMode && activeEffectLabel.innerHTML.includes('SLOW')) {
                    activeEffectLabel.style.display = 'none';
                }
            }

            // 2. SCROLLING
            if (currentDifficulty === 'NORMAL') {
                scrollSpeed = SCROLL_SPEED_BASE + (score / 4.0);
            } else { 
                scrollSpeed = SCROLL_SPEED_BASE + (score / 2.0); 
                const p = Math.min(score / 500, 1); 
                bgColor.r = 15 * (1 - p); bgColor.g = 23 * (1 - p); bgColor.b = 42 * (1 - p);
            }
            
            cameraY += scrollSpeed * physicsDt;
            score = Math.floor(cameraY / 10);
            document.getElementById('scoreDisplay').innerText = score + "m";

            // 3. GENERATION & CULLING
            holes = holes.filter(h => h.y > cameraY - 300);
            if (holes.length > 0 && holes[holes.length-1].y < cameraY + window.innerHeight + 800) {
                generateHoles(holes[holes.length-1].y, cameraY + window.innerHeight + 1600);
            }
            
            powerUps = powerUps.filter(p => p.y > cameraY - 300 && !p.collected);
            generatePowerUpsCheck(cameraY, cameraY + window.innerHeight + 1600);

            // 4. HOLE MOVEMENT
            if (currentDifficulty === 'VERY_HARD') {
                for (let h of holes) {
                    const zoneIndex = Math.floor(h.y / CURRENT_ZONE_HEIGHT);
                    const direction = (zoneIndex % 2 === 0) ? -1 : 1;
                    h.x += direction * VOID_SPEED * physicsDt;
                    if (direction === -1 && h.x < -h.r) h.x = window.innerWidth + h.r; 
                    else if (direction === 1 && h.x > window.innerWidth + h.r) h.x = -h.r;
                }
            }

            // 5. BEAM LOGIC
            if (leftThumb && rightThumb) {
                // -- Resume from Teleport Freeze --
                if (teleportMode) {
                    teleportMode = false;
                    activeEffectLabel.style.display = 'none';
                }

                // -- Slowdown Trigger --
                if (!wasBeamActive && inventory === 'SLOW') {
                    slowTimer = 10.0;
                    inventory = null;
                    updateInventoryUI();
                    spawnSparks(ball.x, ball.y, 15, '#EAB308'); 
                }
                wasBeamActive = true;

                rawBeam = { x1: leftThumb.x, y1: leftThumb.y, x2: rightThumb.x, y2: rightThumb.y };
                const rawX1 = leftThumb.x; const rawY1 = leftThumb.y + cameraY;
                const rawX2 = rightThumb.x; const rawY2 = rightThumb.y + cameraY;
                const dx = rawX2 - rawX1; const dy = rawY2 - rawY1;
                const len = Math.sqrt(dx*dx + dy*dy);
                const unitX = dx / len; const unitY = dy / len;
                const EXTENSION = 3000;
                
                beam = {
                    x1: rawX1 - unitX * EXTENSION, y1: rawY1 - unitY * EXTENSION,
                    x2: rawX2 + unitX * EXTENSION, y2: rawY2 + unitY * EXTENSION,
                    nx: -unitY, ny: unitX,
                    len: len + (EXTENSION * 2),
                    slope: dy/dx
                };
                if (beam.ny > 0) { beam.nx = -beam.nx; beam.ny = -beam.ny; }

            } else {
                // -- Teleport Trigger on Release --
                if (wasBeamActive && inventory === 'TELEPORT') {
                    teleportMode = true;
                    teleportTimer = 10.0;
                    inventory = null; // Consume
                    updateInventoryUI();
                    // Stop ball for easier aiming
                    ball.vx = 0; ball.vy = 0;
                }

                wasBeamActive = false;
                beam = null; rawBeam = null; ball.magnetized = false; 
            }

            // 6. BALL PHYSICS
            if (ball.magnetized && beam) {
                const m = beam.slope;
                const targetY = m * (ball.x - beam.x1) + beam.y1;
                ball.y = targetY - (BALL_RADIUS + BEAM_THICKNESS/2); 
                ball.vy = 0; 
                const angle = Math.atan2(beam.y2 - beam.y1, beam.x2 - beam.x1);
                const gForce = GRAVITY * Math.sin(angle) * ROLL_BOOST; 
                ball.vx += gForce * physicsDt;
                ball.vx *= RAIL_FRICTION; 
            } else {
                ball.vy += GRAVITY * physicsDt; 
                ball.vx *= 0.99; 
                ball.y += ball.vy * physicsDt;
                
                if (beam) {
                    const dx = beam.x2 - beam.x1; const dy = beam.y2 - beam.y1;
                    const t = ((ball.x - beam.x1) * dx + (ball.y - beam.y1) * dy) / (beam.len * beam.len);
                    const closeX = beam.x1 + t * dx; 
                    const closeY = beam.y1 + t * dy;
                    const dist = Math.sqrt((ball.x - closeX)**2 + (ball.y - closeY)**2);
                    
                    if (dist < BALL_RADIUS + SNAP_DISTANCE) {
                        const relX = ball.x - beam.x1; const relY = ball.y - beam.y1;
                        const dotNormal = relX * beam.nx + relY * beam.ny;
                        if (dotNormal > -BALL_RADIUS) {
                            ball.magnetized = true; 
                            spawnSparks(ball.x, ball.y, 3, '#60A5FA'); 
                        }
                    }
                }
            }
            ball.x += ball.vx * physicsDt;

            // 7. COLLISIONS
            
            // Powerups
            for (let p of powerUps) {
                const dx = ball.x - p.x; const dy = ball.y - p.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < p.r + BALL_RADIUS) {
                    collectPowerUp(p);
                    p.collected = true;
                }
            }

            // Voids
            for (let i = holes.length - 1; i >= 0; i--) {
                let h = holes[i];
                const dx = ball.x - h.x; const dy = ball.y - h.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < h.r + 50) {
                    const pull = 1 - (dist / (h.r+50));
                    let f = 700 * pull * physicsDt;
                    if(ball.magnetized) f *= 0.3; 
                    else { 
                        ball.vx += (h.x - ball.x)/dist * f; 
                        ball.vy += (h.y - ball.y)/dist * f; 
                    }
                }
                
                if (dist < h.r - (BALL_RADIUS * 0.4)) { 
                    if (shieldActive) {
                        shieldActive = false;
                        inventory = null; 
                        updateInventoryUI();
                        spawnSparks(h.x, h.y, 20, '#3B82F6'); 
                        holes.splice(i, 1); 
                        ball.vy = -300; 
                    } else {
                        lose("Consumed by Void"); 
                        return; 
                    }
                }
            }

            // Boundaries
            const screenY = ball.y - cameraY;
            if (screenY < -200) lose("Lost in Space");      
            if (screenY > window.innerHeight + 100) lose("Fell Behind"); 
            if (ball.x < 0 || ball.x > window.innerWidth) lose("Off Screen"); 

            updateParticles(physicsDt);
        }

        function collectPowerUp(p) {
            if (inventory === null && !shieldActive) {
                if (p.type === 'SHIELD') {
                    shieldActive = true;
                    inventory = 'SHIELD'; 
                    spawnSparks(p.x, p.y, 10, '#3B82F6');
                    spawnSparks(ball.x, ball.y, 10, '#3B82F6'); 
                } else {
                    inventory = p.type;
                    spawnSparks(p.x, p.y, 10, '#FFF');
                }
                updateInventoryUI();
            }
        }

        function performTeleport(tx, ty) {
            spawnSparks(ball.x, ball.y, 10, '#06B6D4');
            ball.x = tx;
            ball.y = ty + cameraY;
            ball.vx = 0; 
            ball.vy = 0; // Clear momentum
            spawnSparks(ball.x, ball.y, 15, '#06B6D4');
            
            // Resume game immediately
            teleportMode = false;
            activeEffectLabel.style.display = 'none';
            
            updateInventoryUI();
        }

        function updateInventoryUI() {
            let html = '';
            let color = '#475569'; 

            const shieldSVG = `<svg viewBox="0 0 24 24" width="32" height="32">
                <path d="M12 2 L4 2 L4 13 C4 17 7 20 12 22 Z" fill="#3B82F6"/>
                <path d="M12 2 L20 2 L20 13 C20 17 17 20 12 22 Z" fill="#1D4ED8"/>
            </svg>`;
            const slowSVG = `<svg viewBox="0 0 24 24" width="32" height="32" fill="#EAB308"><path d="M15 1H9v2h6V1zm-4 13h2V8h-2v6zm8.03-6.61l1.42-1.42c-.43-.51-.9-.99-1.41-1.41l-1.42 1.42C16.07 4.74 14.12 4 12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9 9-4.03 9-9c0-2.12-.74-4.07-1.97-5.61zM12 20c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"/></svg>`;
            const teleportSVG = `<svg viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="#06B6D4" stroke-width="2"><path d="M12 4c4.418 0 8 1.79 8 4s-3.582 4-8 4-8-1.79-8-4 3.582-4 8-4z"/><path d="M12 12c4.418 0 8 1.79 8 4s-3.582 4-8 4-8-1.79-8-4 3.582-4 8-4z"/></svg>`;

            if (shieldActive) {
                html = shieldSVG;
                color = '#172554';
            } else if (inventory) {
                if (inventory === 'SLOW') {
                    html = slowSVG;
                    html += '<div class="inv-hint" style="position:absolute; bottom: -25px; width: 100px; color:#EAB308; font-weight:bold;">ACTIVATE BEAM</div>';
                    color = '#713F12';
                } else if (inventory === 'TELEPORT') {
                    html = teleportSVG;
                    html += '<div class="inv-hint" style="position:absolute; bottom: -25px; width: 100px; color:#06B6D4; font-weight:bold;">RELEASE BEAM</div>';
                    color = '#155E75';
                }
            }
            
            if (inventory === 'TELEPORT') {
                invSlot.style.borderColor = '#22D3EE';
                invSlot.style.boxShadow = '0 0 15px #06B6D4';
            } else {
                invSlot.style.borderColor = (inventory || shieldActive) ? '#94A3B8' : '#475569';
                invSlot.style.boxShadow = 'none';
            }
            
            invSlot.style.background = color;
            invSlot.innerHTML = html;
        }

        function spawnSparks(x, y, count, color) {
            for(let i=0; i<count; i++) particles.push({ 
                x: x, 
                y: y, 
                vx: (Math.random()-0.5)*200, 
                vy: (Math.random()-0.5)*200, 
                life: 0.3 + Math.random() * 0.2, 
                color: color 
            });
        }

        function updateParticles(dt) {
            for(let i=particles.length-1; i>=0; i--) {
                let p = particles[i]; 
                p.x += p.vx * dt; 
                p.y += p.vy * dt; 
                p.life -= dt;
                if(p.life <= 0) particles.splice(i,1);
            }
        }

        // =================================================================
        // --- RENDERING ---
        // =================================================================

        function draw() {
            ctx.fillStyle = `rgb(${Math.floor(bgColor.r)}, ${Math.floor(bgColor.g)}, ${Math.floor(bgColor.b)})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#FFF';
            for(let s of bgStars) {
                const sy = (s.y - cameraY * s.speed) % canvas.height;
                const dy = sy < 0 ? sy + canvas.height : sy;
                ctx.globalAlpha = 0.3; 
                ctx.beginPath(); ctx.arc(s.x, dy, s.size, 0, Math.PI*2); ctx.fill();
            }
            ctx.globalAlpha = 1;

            for(let p of powerUps) {
                const sy = p.y - cameraY;
                if (sy < -50 || sy > canvas.height + 50) continue;

                let c = '#FFF';
                if(p.type === 'SHIELD') c = '#3B82F6'; 
                else if(p.type === 'TELEPORT') c = '#06B6D4'; 
                else if(p.type === 'SLOW') c = '#EAB308';

                ctx.shadowBlur = 10; ctx.shadowColor = c;
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.strokeStyle = c; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(p.x, sy, p.r, 0, Math.PI*2);
                ctx.fill(); ctx.stroke();

                ctx.save();
                ctx.translate(p.x, sy);
                const iconScale = 0.6; 
                ctx.scale(iconScale, iconScale);

                if (p.type === 'SHIELD') {
                    ctx.fillStyle = c;
                    ctx.beginPath();
                    ctx.moveTo(0, -15); 
                    ctx.lineTo(-12, -15); 
                    ctx.lineTo(-12, 5); 
                    ctx.quadraticCurveTo(-12, 18, 0, 25); 
                    ctx.lineTo(0, -15); 
                    ctx.fill();

                    ctx.fillStyle = '#1D4ED8'; 
                    ctx.beginPath();
                    ctx.moveTo(0, -15); 
                    ctx.lineTo(12, -15); 
                    ctx.lineTo(12, 5); 
                    ctx.quadraticCurveTo(12, 18, 0, 25); 
                    ctx.lineTo(0, -15); 
                    ctx.fill();
                } else if (p.type === 'SLOW') {
                    ctx.fillStyle = c;
                    ctx.beginPath(); ctx.arc(0, 2, 14, 0, Math.PI*2); ctx.fill();
                    ctx.fillRect(-3, -18, 6, 4);
                    ctx.strokeStyle = '#0F172A'; ctx.lineWidth = 3;
                    ctx.beginPath(); ctx.moveTo(0, 2); ctx.lineTo(0, -8); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, 2); ctx.lineTo(6, 2); ctx.stroke();
                } else if (p.type === 'TELEPORT') {
                    ctx.strokeStyle = c; ctx.lineWidth = 3;
                    ctx.beginPath(); ctx.ellipse(0, 0, 18, 8, Math.PI/4, 0, Math.PI*2); ctx.stroke();
                    ctx.beginPath(); ctx.ellipse(0, 0, 18, 8, -Math.PI/4, 0, Math.PI*2); ctx.stroke();
                }

                ctx.restore();
            }
            
            ctx.shadowBlur = 0; 

            for(let h of holes) {
                const sy = h.y - cameraY; 
                if (sy < -100 || sy > canvas.height + 100) continue;
                
                const grad = ctx.createRadialGradient(h.x, sy, h.r * 0.2, h.x, sy, h.r);
                grad.addColorStop(0, '#000'); grad.addColorStop(0.7, '#450a0a'); grad.addColorStop(1, '#7f1d1d');
                ctx.fillStyle = grad; 
                ctx.beginPath(); ctx.arc(h.x, sy, h.r, 0, Math.PI*2); ctx.fill();
                
                ctx.strokeStyle = 'rgba(255,100,100,0.6)'; ctx.lineWidth = 2; ctx.setLineDash([5,5]);
                ctx.beginPath(); ctx.arc(h.x, sy, h.r-(BALL_RADIUS*0.4), 0, Math.PI*2); ctx.stroke(); ctx.setLineDash([]);
                
                if (currentDifficulty === 'VERY_HARD') {
                    const zoneIndex = Math.floor(h.y / CURRENT_ZONE_HEIGHT);
                    const direction = (zoneIndex % 2 === 0) ? -1 : 1;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)'; 
                    ctx.beginPath();
                    const arrowX = h.x + (direction * 10);
                    ctx.moveTo(arrowX, sy); ctx.lineTo(h.x, sy - 5); ctx.lineTo(h.x, sy + 5); ctx.fill();
                }
            }

            if(beam) {
                const sy1 = beam.y1 - cameraY; const sy2 = beam.y2 - cameraY;
                ctx.shadowBlur = ball.magnetized?30:20; ctx.shadowColor = ball.magnetized?'#93C5FD':'#3B82F6';
                ctx.strokeStyle = ball.magnetized?'#60A5FA':'#3B82F6'; 
                ctx.lineWidth = ball.magnetized?BEAM_THICKNESS+2:BEAM_THICKNESS;
                ctx.lineCap = 'round'; 
                ctx.beginPath(); ctx.moveTo(beam.x1, sy1); ctx.lineTo(beam.x2, sy2); ctx.stroke();
                
                ctx.shadowBlur = 0; ctx.strokeStyle = '#FFF'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(beam.x1, sy1); ctx.lineTo(beam.x2, sy2); ctx.stroke();
            }

            const bsy = ball.y - cameraY;
            
            if (shieldActive) {
                ctx.shadowBlur = 20; ctx.shadowColor = '#3B82F6';
                ctx.fillStyle = '#93C5FD';
            } else {
                ctx.fillStyle = ball.magnetized?'#60A5FA':'#FFF'; 
                ctx.shadowBlur = 15; ctx.shadowColor = '#FFF';
            }
            
            ctx.beginPath(); ctx.arc(ball.x, bsy, BALL_RADIUS, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0;
            
            if (shieldActive) {
                ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)';
                ctx.lineWidth = 3;
                ctx.beginPath(); ctx.arc(ball.x, bsy, BALL_RADIUS + 5, 0, Math.PI*2); ctx.stroke();
            }

            for(let p of particles) {
                const psy = p.y - cameraY; 
                ctx.globalAlpha = p.life; 
                ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, psy, 2, 0, Math.PI*2); ctx.fill();
            }
            ctx.globalAlpha = 1;
        }

        function drawUI() {
            uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
            
            if (rawBeam) {
                uiCtx.beginPath(); 
                uiCtx.arc(rawBeam.x1, rawBeam.y1, 30, 0, Math.PI*2); 
                uiCtx.strokeStyle='rgba(255,255,255,0.3)'; 
                uiCtx.lineWidth=2; 
                uiCtx.stroke();
                
                uiCtx.beginPath(); 
                uiCtx.arc(rawBeam.x2, rawBeam.y2, 4, 0, Math.PI*2); 
                uiCtx.fillStyle='rgba(255,255,255,0.8)'; 
                uiCtx.fill();
            }
        }

        function loop(timestamp) {
            if (!isPlaying) return;
            const dt = (timestamp - lastTime) / 1000; 
            lastTime = timestamp;
            update(Math.min(dt, 0.05)); 
            draw(); 
            drawUI(); 
            animationFrameId = requestAnimationFrame(loop);
        }

        // =================================================================
        // --- INPUT ---
        // =================================================================

        function handleTouch(e) {
            if(e.target.closest('.inventory-box') || e.target.classList.contains('game-btn')) return;
            e.preventDefault(); 
            
            if (teleportMode && e.type === 'touchstart') {
                const t = e.changedTouches[0];
                const rect = touchLayer.getBoundingClientRect();
                performTeleport(t.clientX - rect.left, t.clientY - rect.top);
                return;
            }

            const rect = touchLayer.getBoundingClientRect();
            const touches = e.changedTouches;
            const midX = window.innerWidth / 2;
            
            for(let i=0; i<touches.length; i++) {
                const t = touches[i]; 
                const tx = t.clientX - rect.left; 
                const ty = t.clientY - rect.top;
                const isLeft = tx < midX; 

                if(e.type === 'touchstart') {
                    if(isLeft && !leftThumb) leftThumb = { x:tx, y:ty, id:t.identifier };
                    else if(!isLeft && !rightThumb) rightThumb = { x:tx, y:ty, id:t.identifier };
                } else if(e.type === 'touchmove') {
                    if(leftThumb && t.identifier === leftThumb.id) { leftThumb.x=tx; leftThumb.y=ty; }
                    if(rightThumb && t.identifier === rightThumb.id) { rightThumb.x=tx; rightThumb.y=ty; }
                } else if(e.type === 'touchend' || e.type === 'touchcancel') {
                    if(leftThumb && t.identifier === leftThumb.id) leftThumb = null;
                    if(rightThumb && t.identifier === rightThumb.id) rightThumb = null;
                }
            }
        }

        function handleMouse(e) {
            if (teleportMode && e.type === 'mousedown') {
                 const rect = touchLayer.getBoundingClientRect();
                 performTeleport(e.clientX - rect.left, e.clientY - rect.top);
                 return;
            }

            const rect = touchLayer.getBoundingClientRect();
            const mx = e.clientX - rect.left; 
            const my = e.clientY - rect.top;
            
            if(e.type === 'mousedown') {
                const spread = 100; 
                leftThumb = { x: mx - spread, y: my, id: 'm1' }; 
                rightThumb = { x: mx + spread, y: my, id: 'm2' };
            } else if(e.type === 'mousemove' && e.buttons === 1) { 
                const tilt = (mx - window.innerWidth/2) * 0.5;
                leftThumb = { x: mx - 100, y: my - tilt, id: 'm1' }; 
                rightThumb = { x: mx + 100, y: my + tilt, id: 'm2' };
            } else if(e.type === 'mouseup') { 
                leftThumb = null; 
                rightThumb = null; 
            }
        }

        // =================================================================
        // --- STORAGE ---
        // =================================================================

        function saveScore(newScore) {
            try {
                let isBest = false;
                if (currentDifficulty === 'NORMAL' && newScore > bestNormal) {
                    bestNormal = newScore; localStorage.setItem('beam_balance_normal_best', bestNormal); isBest = true;
                } else if (currentDifficulty === 'HARD' && newScore > bestHard) {
                    bestHard = newScore; localStorage.setItem('beam_balance_hard_best', bestHard); isBest = true;
                } else if (currentDifficulty === 'VERY_HARD' && newScore > bestVeryHard) {
                    bestVeryHard = newScore; localStorage.setItem('beam_balance_veryhard_best', bestVeryHard); isBest = true;
                }
                return isBest;
            } catch(e) { 
                return false; 
            }
        }

        function loadScores() {
            try {
                const n = localStorage.getItem('beam_balance_normal_best');
                const h = localStorage.getItem('beam_balance_hard_best');
                const v = localStorage.getItem('beam_balance_veryhard_best');
                bestNormal = n ? parseInt(n) : 0;
                bestHard = h ? parseInt(h) : 0;
                bestVeryHard = v ? parseInt(v) : 0;
            } catch(e) { 
                bestNormal=0; bestHard=0; bestVeryHard=0; 
            }
            updateMenuUI();
        }

        function updateMenuUI() {
            document.getElementById('menuNormalBest').innerText = bestNormal;
            document.getElementById('menuHardBest').innerText = bestHard;
            document.getElementById('menuVeryHardBest').innerText = bestVeryHard;
        }

        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            boot();
        } else {
            window.addEventListener('DOMContentLoaded', boot);
            window.addEventListener('load', boot);
        }
    </script>
</body>
</html>