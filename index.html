<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Beam Balance v0.1.9</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@400;700&display=swap');

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        
        body {
            margin: 0; padding: 0; overflow: hidden;
            background-color: #0F172A;
            touch-action: none;
            font-family: 'Roboto', sans-serif;
            user-select: none; -webkit-user-select: none;
            color: white;
        }

        canvas { display: block; position: absolute; top: 0; left: 0; }
        #gameCanvas { z-index: 1; }
        #uiCanvas { z-index: 2; pointer-events: none; }

        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between;
        }
        
        .top-bar { padding: 20px; display: flex; justify-content: space-between; align-items: flex-start; }
        .score-box { text-align: right; }

        /* MENU STYLES */
        .menu-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 23, 42, 0.98);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; transition: opacity 0.2s;
            pointer-events: auto; touch-action: pan-y;
        }
        
        .title { font-family: 'Orbitron', sans-serif; font-size: 3rem; font-weight: bold; text-align: center; margin-bottom: 10px; letter-spacing: 0.1em; text-shadow: 0 0 15px rgba(59, 130, 246, 0.5); }
        .subtitle { color: #9CA3AF; text-align: center; margin-bottom: 30px; font-size: 0.9rem; line-height: 1.5; max-width: 300px; }
        .highlight-blue { color: #60A5FA; }
        
        .btn-container { width: 100%; max-width: 320px; padding: 0 20px; display: flex; flex-direction: column; gap: 15px; }
        
        .game-btn {
            width: 100%; padding: 15px;
            border-radius: 12px; border: 2px solid;
            cursor: pointer; text-align: center;
            transition: transform 0.1s, opacity 0.1s;
            position: relative; overflow: hidden;
            background: #1E293B;
        }
        .game-btn:active { transform: scale(0.96); opacity: 0.9; }
        
        .btn-normal { border-color: #3B82F6; background: linear-gradient(45deg, #1E3A8A, #1D4ED8); box-shadow: 0 0 15px rgba(37, 99, 235, 0.3); }
        .btn-hard { border-color: #A855F7; background: linear-gradient(45deg, #581C87, #7E22CE); box-shadow: 0 0 15px rgba(126, 34, 206, 0.3); }
        .btn-veryhard { border-color: #EF4444; background: linear-gradient(45deg, #7F1D1D, #B91C1C); box-shadow: 0 0 15px rgba(185, 28, 28, 0.3); }
        .btn-retry { border-color: #22C55E; background: linear-gradient(45deg, #14532D, #15803D); }
        
        .btn-label { display: block; font-size: 1.2rem; font-weight: bold; font-family: 'Orbitron', sans-serif; letter-spacing: 0.05em; margin-bottom: 4px; }
        .btn-score { display: block; font-size: 0.75rem; opacity: 0.8; font-family: monospace; }

        .neon-danger { font-family: 'Orbitron', sans-serif; text-shadow: 0 0 15px rgba(239, 68, 68, 0.8); font-size: 1.5rem; font-weight: bold; }
        .score-main { font-family: monospace; font-size: 2rem; color: #60A5FA; font-weight: bold; }
        .score-sub { font-family: monospace; font-size: 0.8rem; color: #6B7280; }
        
        .zone-hint {
            position: absolute; top: 50%; width: 100px; height: 100px;
            border: 2px dashed rgba(255,255,255,0.15); border-radius: 50%;
            transform: translate(-50%, -50%); display: flex; align-items: center;
            justify-content: center; color: rgba(255,255,255,0.3);
            font-size: 10px; text-align: center; pointer-events: none;
        }

        .hidden { display: none !important; }
        
        #systemLog {
            position: absolute; top: 0; left: 0; padding: 4px;
            color: yellow; background: rgba(0,0,0,0.5);
            font-family: monospace; font-size: 10px; z-index: 9999;
            pointer-events: none;
        }
        
        #forceStartContainer { margin-top: 20px; text-align: center; display: none; }
        .btn-force { background: #333; border: 1px solid #666; padding: 10px 20px; color: #aaa; font-size: 12px; border-radius: 5px; cursor: pointer; }
    </style>
</head>
<body>

    <!-- DEBUG LOG -->
    <div id="systemLog">Booting...</div>

    <!-- CANVAS -->
    <canvas id="gameCanvas"></canvas>
    <canvas id="uiCanvas"></canvas>

    <!-- TOUCH INPUT LAYER -->
    <div id="touchLayer" style="position:absolute; top:0; left:0; width:100%; height:100%; z-index: 5;"></div>

    <!-- HUD -->
    <div id="hudLayer" class="ui-layer">
        <div class="top-bar">
            <div class="neon-danger"><span style="color:#EF4444">DANGER</span> ZONE</div>
            <div class="score-box">
                <div id="scoreDisplay" class="score-main">0m</div>
                <div class="score-sub"><span id="difficultyLabel">NORMAL</span> | BEST: <span id="hudBestScore">0</span>m</div>
            </div>
        </div>
        <div id="leftHint" class="zone-hint" style="left: 15%">LEFT THUMB</div>
        <div id="rightHint" class="zone-hint" style="left: 85%">RIGHT THUMB</div>
    </div>

    <!-- MENU SCREEN -->
    <div id="menuScreen" class="menu-screen">
        <div class="menu-container">
            <div class="title">BEAM<br><span class="highlight-blue">BALANCE</span></div>
            <div class="subtitle">Magnetic Rail System<br>v0.1.9</div>
            
            <div class="btn-container">
                <!-- Normal -->
                <div id="btnNormal" class="game-btn btn-normal">
                    <span class="btn-label">NORMAL</span>
                    <span class="btn-score">BEST: <span id="menuNormalBest">0</span>m</span>
                </div>

                <!-- Hard -->
                <div id="btnHard" class="game-btn btn-hard">
                    <span class="btn-label" style="color:#E9D5FF">HARD</span>
                    <span class="btn-score" style="color:#E9D5FF">BEST: <span id="menuHardBest">0</span>m</span>
                </div>

                <!-- Very Hard -->
                <div id="btnVeryHard" class="game-btn btn-veryhard">
                    <span class="btn-label" style="color:#FECACA">VERY HARD</span>
                    <span class="btn-score" style="color:#FECACA">BEST: <span id="menuVeryHardBest">0</span>m</span>
                </div>
            </div>
            
            <div id="forceStartContainer">
                <button class="btn-force" onclick="forceBoot()">FORCE START GAME</button>
            </div>
        </div>
    </div>

    <!-- GAME OVER SCREEN -->
    <div id="gameOverScreen" class="menu-screen hidden">
        <div class="title" style="font-size: 2.5rem; color: #EF4444; text-shadow: 0 0 20px red;">VOIDED</div>
        <div class="subtitle" id="deathReason">Fell into the void</div>
        
        <div class="score-main" style="font-size: 3rem; margin-bottom: 10px;"><span id="finalScore">0</span>m</div>
        <div class="subtitle">MODE BEST: <span id="endBestScore">0</span>m</div>
        
        <div class="btn-container">
            <div id="btnRetry" class="game-btn btn-retry">
                <span class="btn-label">RETRY</span>
            </div>
            <div id="btnMenu" class="game-btn" style="background: transparent; border-color: #6B7280; color: #9CA3AF;">
                <span class="btn-label" style="font-size: 0.9rem">CHANGE DIFFICULTY</span>
            </div>
        </div>
    </div>

    <!-- GAME LOGIC -->
    <script>
        // --- LOGGER ---
        const sysLog = document.getElementById('systemLog');
        function log(msg) {
            console.log(msg);
            if(sysLog) sysLog.innerText = "SYS: " + msg;
        }
        window.onerror = function(msg, source, line) {
            log(`ERR: ${msg} line ${line}`);
        };

        // --- VARIABLES ---
        let canvas, ctx, uiCanvas, uiCtx, touchLayer;
        let menuScreen, gameOverScreen, leftHint, rightHint;
        let animationFrameId;

        const GRAVITY = 1000;
        const SCROLL_SPEED_BASE = 130;
        const BALL_RADIUS = 12;
        const BEAM_THICKNESS = 8;
        const MIN_GAP = 24 * 2.5;
        const SNAP_DISTANCE = 25;
        const ROLL_BOOST = 1.8;
        const RAIL_FRICTION = 0.98;
        const VOID_SPEED = 40;
        const CURRENT_ZONE_HEIGHT = 500;

        let isPlaying = false, lastTime = 0, score = 0, scrollSpeed = 0, cameraY = 0;
        let currentDifficulty = 'NORMAL';
        let bgColor = { r: 15, g: 23, b: 42 };
        let bestNormal = 0, bestHard = 0, bestVeryHard = 0;

        let ball = { x: 0, y: 0, vx: 0, vy: 0, magnetized: false };
        let holes = [], particles = [], bgStars = [];
        let leftThumb = null, rightThumb = null, beam = null, rawBeam = null;

        // --- INIT SEQUENCE ---
        
        function boot() {
            log("Booting...");
            
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            uiCanvas = document.getElementById('uiCanvas');
            uiCtx = uiCanvas.getContext('2d');
            touchLayer = document.getElementById('touchLayer');
            
            menuScreen = document.getElementById('menuScreen');
            gameOverScreen = document.getElementById('gameOverScreen');
            leftHint = document.getElementById('leftHint');
            rightHint = document.getElementById('rightHint');

            // Bind Events
            const bind = (id, fn) => {
                const el = document.getElementById(id);
                if(!el) return log("Missing " + id);
                el.onclick = (e) => { e.stopPropagation(); fn(); };
                el.ontouchstart = (e) => { e.stopPropagation(); e.preventDefault(); fn(); };
            };

            bind('btnNormal', () => initGame('NORMAL'));
            bind('btnHard', () => initGame('HARD'));
            bind('btnVeryHard', () => initGame('VERY_HARD'));
            bind('btnRetry', () => initGame(currentDifficulty));
            bind('btnMenu', showMenu);

            // Inputs
            touchLayer.ontouchstart = handleTouch;
            touchLayer.ontouchmove = handleTouch;
            touchLayer.ontouchend = handleTouch;
            touchLayer.ontouchcancel = handleTouch;
            touchLayer.onmousedown = handleMouse;
            touchLayer.onmousemove = handleMouse;
            touchLayer.onmouseup = () => { leftThumb = null; rightThumb = null; };

            resize();
            window.addEventListener('resize', resize);
            loadScores();
            
            log("Ready.");
        }

        // --- STORAGE FUNCTIONS ---
        
        // Ensure function name is saveScore (camelCase) to match calls
        function saveScore(newScore) {
            try {
                let isBest = false;
                if (currentDifficulty === 'NORMAL' && newScore > bestNormal) {
                    bestNormal = newScore; localStorage.setItem('beam_balance_normal_best', bestNormal); isBest = true;
                } else if (currentDifficulty === 'HARD' && newScore > bestHard) {
                    bestHard = newScore; localStorage.setItem('beam_balance_hard_best', bestHard); isBest = true;
                } else if (currentDifficulty === 'VERY_HARD' && newScore > bestVeryHard) {
                    bestVeryHard = newScore; localStorage.setItem('beam_balance_veryhard_best', bestVeryHard); isBest = true;
                }
                return isBest;
            } catch(e) { return false; }
        }

        function loadScores() {
            try {
                const n = localStorage.getItem('beam_balance_normal_best');
                const h = localStorage.getItem('beam_balance_hard_best');
                const v = localStorage.getItem('beam_balance_veryhard_best');
                bestNormal = n ? parseInt(n) : 0;
                bestHard = h ? parseInt(h) : 0;
                bestVeryHard = v ? parseInt(v) : 0;
            } catch(e) { log("Storage Disabled"); }
            updateMenuUI();
        }

        function updateMenuUI() {
            const b1 = document.getElementById('menuNormalBest');
            const b2 = document.getElementById('menuHardBest');
            const b3 = document.getElementById('menuVeryHardBest');
            if(b1) b1.innerText = bestNormal;
            if(b2) b2.innerText = bestHard;
            if(b3) b3.innerText = bestVeryHard;
        }

        // --- GAME FLOW ---

        window.forceBoot = function() {
            alert("Force starting...");
            boot();
        };

        function showMenu() {
            gameOverScreen.classList.add('hidden');
            menuScreen.classList.remove('hidden');
            updateMenuUI();
        }

        function initGame(difficulty) {
            if(isPlaying) return;
            log("Start: " + difficulty);
            currentDifficulty = difficulty;
            
            const dl = document.getElementById('difficultyLabel');
            const hb = document.getElementById('hudBestScore');
            
            dl.innerText = difficulty;
            let best = 0;
            if(difficulty === 'NORMAL') best = bestNormal;
            else if(difficulty === 'HARD') best = bestHard;
            else best = bestVeryHard;
            hudBestScore.innerText = best;

            resetGameLogic();
            
            menuScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            leftHint.style.opacity = 0; rightHint.style.opacity = 0;

            isPlaying = true;
            lastTime = performance.now();
            cancelAnimationFrame(animationFrameId);
            requestAnimationFrame(loop);
        }

        function resetGameLogic() {
            resize();
            score = 0; cameraY = 0; scrollSpeed = SCROLL_SPEED_BASE;
            bgColor = { r: 15, g: 23, b: 42 };
            ball = { x: window.innerWidth/2, y: 100, vx: 0, vy: 0, magnetized: false };
            holes = []; generateHoles(window.innerHeight * 0.75, window.innerHeight * 2.5);
            particles = []; leftThumb = null; rightThumb = null; beam = null; rawBeam = null;
        }

        function generateHoles(startY, endY) {
            const stepY = 50; let currentY = startY;
            while (currentY < endY) {
                const attempts = 20; 
                for (let i = 0; i < attempts; i++) {
                    const r = 25 + Math.random() * 30; 
                    const margin = r + 10;
                    const candidateX = margin + Math.random() * (window.innerWidth - margin * 2);
                    const candidateY = currentY + (Math.random() * 60 - 30); 
                    const newHole = { x: candidateX, y: candidateY, r: r, id: Math.random() };
                    let valid = true;
                    for (let h of holes) {
                        if (Math.abs(h.y - newHole.y) > 200) continue;
                        const dx = h.x - newHole.x; const dy = h.y - newHole.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < h.r + newHole.r + MIN_GAP) { valid = false; break; }
                    }
                    if (valid) holes.push(newHole);
                }
                currentY += stepY;
            }
            holes.sort((a,b) => a.y - b.y);
        }

        function update(dt) {
            if (currentDifficulty === 'NORMAL') scrollSpeed = SCROLL_SPEED_BASE + (score / 4);
            else {
                scrollSpeed = SCROLL_SPEED_BASE + (score / 1.5); 
                const p = Math.min(score / 500, 1); 
                bgColor.r = 15 * (1 - p); bgColor.g = 23 * (1 - p); bgColor.b = 42 * (1 - p);
            }
            
            cameraY += scrollSpeed * dt;
            score = Math.floor(cameraY / 10);
            document.getElementById('scoreDisplay').innerText = score + "m";

            holes = holes.filter(h => h.y > cameraY - 300);
            if (holes.length > 0 && holes[holes.length-1].y < cameraY + window.innerHeight + 800) {
                generateHoles(holes[holes.length-1].y, cameraY + window.innerHeight + 1600);
            }

            if (currentDifficulty === 'VERY_HARD') {
                for (let h of holes) {
                    const z = Math.floor(h.y / CURRENT_ZONE_HEIGHT);
                    const d = (z % 2 === 0) ? -1 : 1;
                    h.x += d * VOID_SPEED * dt;
                    if (d === -1 && h.x < -h.r) h.x = window.innerWidth + h.r; 
                    else if (d === 1 && h.x > window.innerWidth + h.r) h.x = -h.r;
                }
            }

            if (leftThumb && rightThumb) {
                rawBeam = { x1: leftThumb.x, y1: leftThumb.y, x2: rightThumb.x, y2: rightThumb.y };
                const rawX1 = leftThumb.x; const rawY1 = leftThumb.y + cameraY;
                const rawX2 = rightThumb.x; const rawY2 = rightThumb.y + cameraY;
                const dx = rawX2 - rawX1; const dy = rawY2 - rawY1;
                const len = Math.sqrt(dx*dx + dy*dy);
                const unitX = dx / len; const unitY = dy / len;
                const EXTENSION = 3000;
                beam = {
                    x1: rawX1 - unitX * EXTENSION, y1: rawY1 - unitY * EXTENSION,
                    x2: rawX2 + unitX * EXTENSION, y2: rawY2 + unitY * EXTENSION,
                    nx: -unitY, ny: unitX, len: len + (EXTENSION * 2),
                };
                if (beam.ny > 0) { beam.nx = -beam.nx; beam.ny = -beam.ny; }
            } else {
                beam = null; rawBeam = null; ball.magnetized = false; 
            }

            if (ball.magnetized && beam) {
                const m = (beam.y2 - beam.y1) / (beam.x2 - beam.x1);
                const targetY = m * (ball.x - beam.x1) + beam.y1;
                ball.y = targetY - (BALL_RADIUS + BEAM_THICKNESS/2);
                ball.vy = 0; 
                const angle = Math.atan2(beam.y2 - beam.y1, beam.x2 - beam.x1);
                const gForce = GRAVITY * Math.sin(angle) * ROLL_BOOST; 
                ball.vx += gForce * dt;
                ball.vx *= RAIL_FRICTION; 
            } else {
                ball.vy += GRAVITY * dt; ball.vx *= 0.99; ball.y += ball.vy * dt;
                if (beam) {
                    const dx = beam.x2 - beam.x1; const dy = beam.y2 - beam.y1;
                    const t = ((ball.x - beam.x1) * dx + (ball.y - beam.y1) * dy) / (beam.len * beam.len);
                    const closeX = beam.x1 + t * dx; const closeY = beam.y1 + t * dy;
                    const dist = Math.sqrt((ball.x - closeX)**2 + (ball.y - closeY)**2);
                    if (dist < BALL_RADIUS + SNAP_DISTANCE) {
                        const relX = ball.x - beam.x1; const relY = ball.y - beam.y1;
                        const dotNormal = relX * beam.nx + relY * beam.ny;
                        if (dotNormal > -BALL_RADIUS) {
                            ball.magnetized = true; spawnSparks(ball.x, ball.y, 3); 
                        }
                    }
                }
            }
            ball.x += ball.vx * dt;

            for (let h of holes) {
                const dx = ball.x - h.x; const dy = ball.y - h.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < h.r + 50) {
                    const pull = 1 - (dist / (h.r+50));
                    let f = 700 * pull * dt;
                    if(ball.magnetized) f *= 0.3;
      
